<!DOCTYPE html>
<html style="background-color:black;" lang="en">
  <head>
    <meta charset='utf-8'/>
    <meta name='viewport' content='width=device-width, initial-scale=1.0'/>
    <title>Fractal flame</title>
    <link rel="stylesheet" href="https://raw.githubusercontent.com/Just-Roma/Web/main/Just-Something-Pretty/Fractal-Flame/FractalFlame.css"/>
    <script id="worker" type="javascript/worker">

      class Matrix{

      constructor(width, height) {
        this.width = width;
        this.height = height;
        // Each entry stores RGB(first 3 positions) and a counter(how many times a pixel was hit).
        this.entries = Array.from({length: width*height*4}, () => 0);
      }
				
      get(x, y) {return this.entries[y*this.width*4 + x*4+3];}	

      // Set RGB. There can be different ways. This one just sums up the color values.
      set(x, y, value){
        this.entries[y*this.width*4 + x*4]   += value[0];
        this.entries[y*this.width*4 + x*4+1] += value[1];
        this.entries[y*this.width*4 + x*4+2] += value[2];
      }

      // Increases the counter.
        inc(x, y) {this.entries[y*this.width*4 + x*4+3]++;}
      }

      
      /* The set of functions with parameters.
         "scaleX/scaleY" tells how to scale the images.
         This script has 2 types of extra paremeters(static and dynamic), which influence the final image result.
         "setExtraPars" decides whether to assign extra parameters dynamically. This is done below in worker's onmessage.

         To extend the capabilities of the script some other parameters can be added to each Function.
      */
      let Functions = {

      'Linear': {'func': function(x, y){
        return [x, y];
      }, 'scaleX': 6, 'scaleY': 6, 'setExtraPars': false},

      'Sinusoidal': {'func': function(x, y){
        return [Math.sin(x), Math.sin(y)];
      }, 'scaleX': 2.5, 'scaleY': 2.5, 'setExtraPars': false},

      'Spherical': {'func': function(x, y){
        let rSquare = x*x + y*y;
        return [x/rSquare, y/rSquare];
      }, 'scaleX': 10, 'scaleY': 10, 'setExtraPars': false},

      'Swirl': {'func': function(x, y){
        let rSquare = x*x + y*y;
        return [x*Math.sin(rSquare) - y*Math.cos(rSquare), x*Math.cos(rSquare) + y*Math.sin(rSquare)];
      }, 'scaleX': 9, 'scaleY': 6, 'setExtraPars': false},

      'Horseshoe': {'func': function(x, y){
        let r = Math.sqrt(x*x + y*y);
        return [(x-y)*(x+y)/r, 2*x*y/r];
      }, 'scaleX': 9, 'scaleY': 6, 'setExtraPars': false},

      'Polar': {'func': function(x, y){
        return [Math.atan2(x,y)/Math.PI, Math.sqrt(x*x + y*y)-1];
      }, 'scaleX': 2.3, 'scaleY': 2.5, 'setExtraPars': false},

      'Handkerchief': {'func': function(x, y){
        let r = Math.sqrt(x*x + y*y);
        let Teta = Math.atan2(x, y);
        return [r*Math.sin(Teta+r), r*Math.cos(Teta-r)];
      }, 'scaleX': 6, 'scaleY': 7, 'setExtraPars': false},

      'Heart': {'func': function(x, y){
        let r = Math.sqrt(x*x + y*y);
        let Teta = Math.atan2(x, y)*r;
        return [r*Math.sin(Teta), -r*Math.cos(Teta)];
      }, 'scaleX': 9, 'scaleY': 7, 'setExtraPars': false},

      'Heart2': {'func': function(x, y){
        let r = Math.sqrt(x*x + y*y);
        let Teta = Math.atan(x/y)*r;
        return [r*Math.sin(Teta), -r*Math.cos(Teta)];
      }, 'scaleX': 9, 'scaleY': 7, 'setExtraPars': false},

      'Disc': {'func': function(x, y){
        let r = Math.PI * Math.sqrt(x*x + y*y);
        let Teta = Math.atan2(x, y);
        return [Teta * Math.sin(r), Teta * Math.cos(r)];
      }, 'scaleX': 8, 'scaleY': 8, 'setExtraPars': false},

      'Spiral': {'func': function(x, y){
        let r = Math.sqrt(x*x + y*y);
        let Teta = Math.atan2(x, y);
        return [(Math.cos(Teta) + Math.sin(r))/r, (Math.sin(Teta) - Math.cos(r))/r];
      }, 'scaleX': 12, 'scaleY': 12, 'setExtraPars': false},

      'Hyperbolic': {'func': function(x, y){
        let r = Math.sqrt(x*x + y*y);
        let Teta = Math.atan2(x, y);
        return [Math.sin(Teta)/r, r*Math.cos(Teta)];
      }, 'scaleX': 10, 'scaleY': 10, 'setExtraPars': false},

      'Diamond': {'func': function(x, y){
        let r = Math.sqrt(x*x + y*y);    
        let Teta = Math.atan2(x,y);
        let a = Math.sin(Teta+r);
        let b = Math.sin(Teta-r);
        return [(a+b)/2, (a-b)/2];
      }, 'scaleX': 2.1, 'scaleY': 2.1, 'setExtraPars': false},

      'Ex': {'func': function(x, y){
        let r = Math.sqrt(x*x + y*y);
        let Teta = Math.atan2(x, y);
        let p0 = Math.sin(Teta+r);
        let p1 = Math.cos(Teta-r);
        return [r*(Math.pow(p0,3) + Math.pow(p1,3)), r*(Math.pow(p0,3) - Math.pow(p1,3))];
      }, 'scaleX': 6, 'scaleY': 10, 'setExtraPars': false},

      'Julia': {'func': function(x, y){
        let r = Math.sqrt(Math.sqrt(x*x + y*y));
        let Teta = Math.atan2(x, y);
        let Omega = [0,Math.PI][Math.round(Math.random())];
        return [Math.cos(Teta/2 + Omega) * r, Math.sin(Teta/2 + Omega) * r];
      }, 'scaleX': 4, 'scaleY': 4, 'setExtraPars': false},

      'Bent': {'func': function(x, y){
        if (x >= 0 && y >= 0) return [x,y];
        else if (x < 0 && y >= 0) return [2*x,y];
        else if (x >= 0 && y < 0) return [x,y/2];
        else return [2*x,y/2];
       }, 'scaleX': 12, 'scaleY': 6, 'setExtraPars': false},

      'Waves': {'func': function(x, y, extraPars){
        return [x + extraPars.b*Math.sin(y/extraPars.c**2), y + extraPars.e*Math.sin(x/extraPars.f**2)];
      }, 'scaleX': 6, 'scaleY': 6, 'setExtraPars': true},

      'Fisheye': {'func': function(x, y){
        let r = 2/(Math.sqrt(x*x + y*y)+1);
        return [y*r, x*r];
      }, 'scaleX': 4, 'scaleY': 4, 'setExtraPars': false},

      'Popcorn': {'func': function(x, y, extraPars){
        return [x + extraPars.c*Math.sin(Math.tan(3*y)), y + extraPars.f*Math.sin(Math.tan(3*x))];
      }, 'scaleX': 7, 'scaleY': 7, 'setExtraPars': true},

      'Exponential': {'func': function(x, y){
        let Exp = Math.exp(x-1);
        return [Exp * Math.cos(Math.PI*y), Exp * Math.sin(Math.PI*y)];
      }, 'scaleX': 3, 'scaleY': 3, 'setExtraPars': false},

      'Power': {'func': function(x, y){
        let Teta = Math.atan2(x, y);
        let r = Math.pow(Math.sqrt(x*x + y*y), Math.sin(Teta));
        return [r * Math.cos(Teta), r * Math.sin(Teta)];
      }, 'scaleX': 5, 'scaleY': 7, 'setExtraPars': false},

      'Cosine': {'func': function(x, y){
        return [Math.cos(Math.PI*x)*Math.cosh(y), -Math.sin(Math.PI*x)*Math.sinh(y)];
      }, 'scaleX': 5, 'scaleY': 4, 'setExtraPars': false},

      'Rings': {'func': function(x, y, extraPars){
        let r = Math.sqrt(x*x + y*y);
        let Teta = Math.atan2(x, y);
        let c = extraPars.c;
        let par = ((r+c*c) % (2*c*c)) - c*c + r*(1-c*c);
        return [par*Math.cos(Teta), par*Math.sin(Teta)];
      }, 'scaleX': 5, 'scaleY': 3, 'setExtraPars': true},


      'Blob': {'func': function(x, y, extraPars){
        let r = Math.sqrt(x*x + y*y);
        let Teta = Math.atan2(x, y);
        let par = r*(extraPars.p2+((extraPars.p1-extraPars.p2)/2)*(Math.sin(extraPars.p3*Teta)+1));
        return[par*Math.cos(Teta), par*Math.sin(Teta)];
      }, 'scaleX': 8, 'scaleY': 8, 'setExtraPars': false},

      'PDJ': {'func': function(x, y, extraPars){
        return[Math.sin(extraPars.a*y) - Math.cos(extraPars.b*x), Math.sin(extraPars.c*x) - Math.cos(extraPars.d*y)];
      }, 'scaleX': 3, 'scaleY': 4, 'setExtraPars': true},

      'Pipe': {'func': function(x, y){
        let r = Math.sqrt(x*x + y*y);
        let Teta = Math.atan2(x, y);
        let p1 = Math.PI*x*x;
        let t = Teta + y - p1*Math.trunc((2*Teta*y)/p1);
        if(t > p1/2) return[r*Math.sin(Teta-p1/2), r*Math.cos(Teta-p1/2)];
        else return[r*Math.sin(Teta+p1/2), r*Math.cos(Teta+p1/2)];
      }, 'scaleX': 6, 'scaleY': 6, 'setExtraPars': false},

      'Eyefish': {'func': function(x, y){
        let r = 2/(Math.sqrt(x*x + y*y) + 1);
        return[r*x, r*y];
      }, 'scaleX': 8, 'scaleY': 4, 'setExtraPars': false},

      'Bubble': {'func': function(x, y){
        let r = 1/(0.25*(x*x + y*y) + 1);
        return[r*x, r*y];
      }, 'scaleX': 8, 'scaleY': 4, 'setExtraPars': false},

      'Cylinder': {'func': function(x, y){
        return[Math.sin(x), y];
      }, 'scaleX': 8, 'scaleY': 4, 'setExtraPars': false},

      'Tangent': {'func': function(x, y){
        return[Math.sin(x)/Math.cos(y), Math.tan(y)];
      }, 'scaleX': 12, 'scaleY': 12, 'setExtraPars': false},

      'Cross': {'func': function(x, y){
        let par = Math.sqrt(1/(x*x-y*y)**2);
        return[par*x, par*y];
      }, 'scaleX': 12, 'scaleY': 12, 'setExtraPars': false}

      }
      
      // This is the part where the main job is done. All the algorithms from the Scott Drave's paper are here.
      self.onmessage = function(message){

        /* All the necessary for the calculations variables are defined here. */ 
        let width  = message.data[0];
        let height = message.data[1];

        // The set of affine coefficients.
        let coefs  = message.data[2][0];

        // Used to choose a random int.
        let len = coefs.length-1;

        // The set of RGB values, associated with affine coeffs.
        let rgb = message.data[2][1];

        // The histogram for storing results from the chaos game.
        let fractalFlame = new Matrix(width, height);

        // Used to filtering the "fractalFlame".
        let fractalFlameSpare = new Matrix(width, height);

        // X/Y are the temporary values, cur_dot is the final coordinate. chosenF is the function chosen by the user. 
        // ranCoef is a variable which stores the index of the randomly chosen coefficient.
        let X, Y, cur_dot, chosenF = Functions[message.data[3]].func, ranCoef;        

        let scaleX = Functions[message.data[3]].scaleX;
        let scaleY = Functions[message.data[3]].scaleY;
        let offsetX, offsetY;
        
        // The histogram(fractalFlame) is a matrix which uses standard JS numbers, each such number takes 8 bytes of memory.
        // It can slow down the script if this matrix would be sent to the main thread from the FractalFlame.js.
        // So an instance of the ImageData is created, which uses Uint8ClampedArray, so each number uses only 1 byte of memory.
        let bitMap = new ImageData(width, height);
        
        // These 3 variables are used later for the Gamma correction. 
        // "Gamma" var can be adjusted or even be set by the user, but it basically effects the brightness of an image.
        let max = 0, GammaMod, Gamma = 2.2;

        // This object will hold extra parameters for functions.
        let extraPars = {};
        let setExtraPars = Functions[message.data[3]].setExtraPars;

        // Some results must be shifted to make pictures more attractive.
        // Besides some functions need extra parameters. Static dependent parameters are defined here.
        switch (message.data[3]){

          case 'Spiral': offsetX = -Math.floor(width/7);
                         offsetY = Math.floor(height/3);
                         break;

          case 'Blob': offsetX = 0;
                       offsetY = 0;
                       extraPars.p1 = Math.random();
                       extraPars.p2 = 1+Math.random();
                       extraPars.p3 = 1+30*Math.random();
                       break;

          case 'PDJ': offsetX = Math.round(width*0.3);
                      offsetY = Math.round(height*0.15);
                      break;

          default: offsetX = 0;
                   offsetY = 0;
        }

        // Since the calculation process is very slow, the web worker sends stepwise an actualized frame to the main script.
        for (let frame = 0; frame < 50; frame++){
          for (let point = 0; point < 1000000; point++){

            // Create a  a random point in the bi-unit square.
            X = Math.random()*2-1;
            Y = Math.random()*2-1;

            // Iterate 5 times without plotting to get closer to the solution. 
            // Larger number of iterations brings the points closer to the final solution, but it also slows down the creation significantly.
            // In theory it can be a distinct user-defined parameter, because low values change the image's appearence. So the user could choose between 1 and 20 for instance.
            for (let j = -5; j < 0; j++){

              ranCoef = Math.round(Math.random()*len);
              
              // Extra parameters are set here. For now its just one mode, but other modes can be added.
              // Though these parameters could be user-defined and give users the whole control over the image's appearence, 
              // it also would make user experiance worse, because (probably) most combinations would result in awful result. 
              // Besides there are billion combinations. So let the script handle this part.
              if (setExtraPars){
                extraPars.a = coefs[ranCoef][0];
                extraPars.b = coefs[ranCoef][1];
                extraPars.c = coefs[ranCoef][2];
                extraPars.d = coefs[ranCoef][3];
                extraPars.e = coefs[ranCoef][4];
                extraPars.f = coefs[ranCoef][5];
              }

              [X,Y] = chosenF(coefs[ranCoef][0]*X + coefs[ranCoef][1]*Y + coefs[ranCoef][2], 
                                 coefs[ranCoef][3]*X + coefs[ranCoef][4]*Y + coefs[ranCoef][5],
                                 extraPars);
            }

            cur_dot = [width-Math.floor((scaleX/2-X)/scaleX*width) + offsetX, height-Math.floor((scaleY/2-Y)/scaleY*height) + offsetY];


            /* This block works with the histogram(fractalFlame), so if symmetry is needed it can be introduced here.
               Some code for symmetry variation can be injected within this "if" block.
               As example extra helper functions can be defined, which take care of different symmetry methods.
               Each fractal function could have some parameter which references one of those symmetry-functions.
            */   
            if (cur_dot[0] >= 0 && cur_dot[0] < width && cur_dot[1] >= 0 && cur_dot[1] < height){ 
              fractalFlame.set(cur_dot[0],cur_dot[1], rgb[ranCoef]);
              fractalFlame.inc(cur_dot[0],cur_dot[1]);
            }
          }


          /* Filtering is done here. Since there are at least several filtering methods, some filter variation can be programmed here.
             The filtering mode can also be user-defined.
          */
          max = 0;

          for (let i = width*height*4-1; i > 2; i -= 4){
            // Scale the colors by counter and take logarithm of it.
            if (fractalFlame.entries[i]){
              fractalFlameSpare.entries[i-3] = fractalFlame.entries[i-3]/fractalFlame.entries[i];
              fractalFlameSpare.entries[i-2] = fractalFlame.entries[i-2]/fractalFlame.entries[i];
              fractalFlameSpare.entries[i-1] = fractalFlame.entries[i-1]/fractalFlame.entries[i];
              fractalFlameSpare.entries[i] = Math.log10(fractalFlame.entries[i]);
            }
            max = Math.max(fractalFlameSpare.entries[i], max);
          }

          for (let i = width*height*4-1; i > 2; i -= 4){
            GammaMod = Math.pow(fractalFlameSpare.entries[i]/max,1/Gamma);
            bitMap.data[i]   = 255*fractalFlameSpare.entries[i]/max;
            bitMap.data[i-3] = fractalFlameSpare.entries[i-3]*GammaMod;
            bitMap.data[i-2] = fractalFlameSpare.entries[i-2]*GammaMod;
            bitMap.data[i-1] = fractalFlameSpare.entries[i-1]*GammaMod;
          }
          
          self.postMessage(bitMap);
        }
        self.postMessage(true);
      }


    </script>
    <script type="text/javascript" src="https://raw.githubusercontent.com/Just-Roma/Web/main/Just-Something-Pretty/Fractal-Flame/FractalFlame.js" defer></script>
    <script type="text/javascript" src="https://raw.githubusercontent.com/Just-Roma/Web/main/Just-Something-Pretty/Fractal-Flame/EventListeners.js" defer></script>
  </head>

  <body>
    
    <div id='mainPage'>

      <div id='infoPage'>
        <p class="InfoParagraph"> The main intention of this page is to create aesthetically pleasing images. 
          Though most of results will be interesting/beautuful, there is a chance that something weird/ugly will be produced.
          In that case just click on the "Create" button and wait for the next result.
          The creation of images is slow, so to get a good result you have to wait some time. Depending on the fractal type it can take up 
          to 1 minute. Every few seconds the image is modified, so meanwhile you can just watch the creation process.
          <br><br>
          There are two parameters and buttons:
        </p>
        <ol id='list'>
          <li>"Fractal type" defines the function, which will be used to produce the images. It is the main part. Changing it does not automatically create new image.</li>
          <br>
          <li>"Magic number" defines the number of affine coefficient sets. These are geometrical transformations. "Magic number" affects the appearence of the final image. Larger values increase the creation time. Changing it does not automatically create new image.</li>
          <br>
          <li>"Create" button creates a new image. Every time you press it, it becomes shortly disabled until the first frame is done. After that you can use it again.</li>
          <br>
          <li>"Info"/"Back" changes between this Info menu and the canvas. While reading this an image is being created. When you get back, it will be more attractive.</li>
        </ol>
        <p class="InfoParagraph">
          Unfortunately there is no way to predict how the next image will look like. Each new picture gets its own random affine transformations and colors.
          There is practically no chance to get the same image again. Although most images will be build according to some pattern, some will be extraordinary.
        </p>
      </div>

      <canvas id='Canvas'></canvas>

      <div id='Menu'>

        <h1>Fractal flame</h1>
        <div class="selectDiv">
          <label for="functions">Fractal type:</label>
          <select name="functions" id="selectFunc">
            <option value='Linear' selected='selected'>Linear</option>
            <option value='Sinusoidal'>Sinusoidal</option>
            <option value='Spherical'>Spherical</option>
            <option value='Swirl'>Swirl</option>
            <option value='Horseshoe'>Horseshoe</option>
            <option value='Polar'>Polar</option>
            <option value='Handkerchief'>Handkerchief</option>
            <option value='Heart'>Heart</option>
            <option value='Heart2'>Heart2</option>
            <option value='Disc'>Disc</option>
            <option value='Spiral'>Spiral</option>
            <option value='Hyperbolic'>Hyperbolic</option>
            <option value='Diamond'>Diamond</option>
            <option value='Ex'>Ex</option>
            <option value='Julia'>Julia</option>
            <option value='Bent'>Bent</option>
            <option value='Waves'>Waves</option>
            <option value='Fisheye'>Fisheye</option>
            <option value='Popcorn'>Popcorn</option>
            <option value='Exponential'>Exponential</option>
            <option value='Power'>Power</option>
            <option value='Cosine'>Cosine</option>
            <option value='Rings'>Rings</option>
            <option value='Blob'>Blob</option>
            <option value='PDJ'>PDJ</option>
            <option value='Pipe'>Pipe</option>
            <option value='Eyefish'>Eyefish</option>
            <option value='Bubble'>Bubble</option>
            <option value='Cylinder'>Cylinder</option>
            <option value='Tangent'>Tangent</option>
            <option value='Cross'>Cross</option>
          </select>
        </div>

        <!-- Each function has an associated number of affine transformations. 
             The options below are for the linear function.
             Changing the type of function("Fractal type") forces the script to change these numbers according to the new choice.-->
        <div class="selectDiv">
          <label for="affines">Magic number:</label>
          <select name="affines" id="selectAffine">
            <option value='4'>4</option>
            <option value='5'>5</option>
            <option value='6'>6</option>
            <option value='7'>7</option>
            <option value='8'>8</option>
            <option value='9'>9</option>
            <option value='10'>10</option>
            <option value='11'>11</option>
            <option value='12'>12</option>
            <option value='13'>13</option>
            <option value='14'>14</option>
            <option value='15'>15</option>
            <option value='16'>16</option>
            <option value='17'>17</option>
            <option value='18'>18</option>
            <option value='19'>19</option>
            <option value='20' selected='selected'>20</option>
          </select>
        </div>

        <button class="Button" id='ButtonCreate'>Create</button>

        <button class="Button" id='ButtonInfo'>Info</button>

      </div>
    </div>
  </body>
</html>
