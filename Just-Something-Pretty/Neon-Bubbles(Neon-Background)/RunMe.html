<!DOCTYPE html>
<html lang='en'>
	<head>
		<meta charset='utf-8'/>
		<meta name='viewport' content='width=device-width, initial-scale=1.0'/>
		<title>Neon Bubbles</title>
		<style>
			html{
				width:100%;
				height:100%;
				background-color:rgb(0,0,0);
			}

			body{
				width:100%;
				height:100%;
				margin:0px;
			}

			/* Chage the scrollbar */
			::-webkit-scrollbar {
				background-color:rgb(0,0,0);
				display:inline-block;
				width:2px;
				height:0px;
			}

			::-webkit-scrollbar-thumb {
				background-color: #ff0;
				border-radius: 2px;
			}

			::-webkit-scrollbar-track {
				background: transparent;
			}

			#Canvas{
				width:84%; /* It's 1% less than it should be, because otherwise input tags twitch in Opera */
				display: inline-block;
			}

			#Menu{
				width:14%;
				position:fixed;
				display: inline-block;
			}

			h1{
				width:100%;
				text-align: center;
				font-size:calc(1.5vw + 1vh);
				color:rgb(255,255,155);
				text-shadow:
					0 0 7px  #ff0,
					0 0 10px #ff0,
					0 0 15px #ff0,
					0 0 25px #ff0,
					0 0 32px #ff0,
					0 0 42px #ff0;
				display: inline-block;
			}

			.SettingsButtons{
				width:100%;
				padding:0px;
				font-size:calc(0.8vw + 0.8vh);
				margin:0px;
				text-align: center;
				display:block;
				color:rgb(255,255,0);
			}

			/* Based on https://css-tricks.com/styling-cross-browser-compatible-range-inputs-css/ */
			input[type=range] {
				-webkit-appearance: none; /* Hides the slider so that custom slider can be made */
				width: 100%; /* Specific width is required for Firefox. */
			}

			input[type=range]:focus {
				outline: none; /* Apperantly an outline exists somewhere */
			}

			input[type=range]::-webkit-slider-thumb {
				-webkit-appearance: none;
			}

			/* For edge */
			input[type=range]::-ms-track{
				width: 100%;
				cursor: pointer;

				/* Hides the slider so custom styles can be added */
				background: transparent; 
				border-color: transparent;
				color: transparent;
			}

			input[type=range]::-webkit-slider-thumb{
				height: 2vh;
				width: 2vw;
				border-radius: 5px;
				cursor: pointer;
				margin: 0px;
				padding:0px;
			}

			/* All the same stuff for Firefox */
			input[type=range]::-moz-range-thumb{
				height: 2vh;
				width: 2vw;
				border-radius: 5px;
				border:none;
				cursor: pointer;
				margin: 0px;
				padding:0px;
			}

			input{
				background-color:rgb(0,0,0);
			}

			/* The thumbs(draggable things) are colored here*/
			#backgroundRed::-webkit-slider-thumb, #bubblesRed::-webkit-slider-thumb{
				background-image: radial-gradient(rgb(255,0,0), black 80%);
			}
			#backgroundRed::-moz-range-thumb, #bubblesRed::-moz-range-thumb{
				background-image: radial-gradient(rgb(255,0,0), black 80%);
			}

			#backgroundGreen::-webkit-slider-thumb, #bubblesGreen::-webkit-slider-thumb{
				background-image: radial-gradient(rgb(0,255,0), black 80%);
			}
			#backgroundGreen::-moz-range-thumb, #bubblesGreen::-moz-range-thumb{
				background-image: radial-gradient(rgb(0,255,0), black 80%);
			}

			#backgroundBlue::-webkit-slider-thumb, #bubblesBlue::-webkit-slider-thumb{
				background-image: radial-gradient(rgb(0,0,255), black 80%);
			}
			#backgroundBlue::-moz-range-thumb, #bubblesBlue::-moz-range-thumb{
				background-image: radial-gradient(rgb(0,0,255), black 80%);
			}

			#Setting_bubbles_number::-webkit-slider-thumb{
				background-image: radial-gradient(rgb(255,255,0), black 80%);
			}
			#Setting_bubbles_number::-moz-range-thumb{
				background-image: radial-gradient(rgb(255,255,0), black 80%);
			}

			/* Separate the blocks from each other */
			#Settings_Background_Colors{
				margin-top:2vh;
				margin-bottom:4vh;
				line-height:3.5vh;
			}
			#Settings_Bubbles_Colors{
				margin-bottom:4vh;
				line-height:3.5vh;
			}
			#Settings_Number_Of_Bubbles{
				margin-bottom:4vh;
			}

			input[type=range]::-webkit-slider-runnable-track {
				width: 100%;
				height: 2.6vh;
				cursor: pointer;
				box-shadow: 0px 0px 2px #FFFF00;
				background-color: #000000;
				border:calc(0.1vw + 0.1vh) solid #FFFF00;
				border-radius: 6px;
			}

			input[type=range]:focus::-webkit-slider-runnable-track{
			  background: #000000;
			}

			input[type=range]::-moz-range-track {
				width: 100%;
				height: 2.6vh;
				cursor: pointer;
				box-shadow: 0px 0px 2px #FFFF00;
				background-color: #000000;
				border:calc(0.1vw + 0.1vh) solid #FFFF00;
				border-radius: 6px;
			}

			#Change_Background_Button{
				width:100%;
				height:4vh;
				margin:0.2vw;
				border:none;
				padding:0px;
				cursor:pointer;
				font-size:calc(0.9vw + 0.9vh);
				background: #000;
				text-shadow:
					0 0 0px  #000,
					0 0 1px  #000,
					0 0 2px  #000;

				box-shadow:
					inset 0 0 4px #ff0,
					0 0 0px  #ff0,
					0 0 1px  #ff0,
					0 0 2px  #ff0,
					0 0 3px  #ff0,
					0 0 5px  #ff0;

				animation: backAndForth 5s infinite;
			}

			/* Change the button's appearance on click. */
			#Change_Background_Button:active{
				box-shadow:
					inset 0 0 4px #ff0,
					0 0 0px  #ff0,
					0 0 1px  #ff0,
					0 0 2px  #ff0,
					0 0 3px  #ff0,
					0 0 4px  #ff0,
					0 0 5px  #ff0,
					0 0 6px  #ff0,
					0 0 7px  #ff0,
					0 0 8px  #ff0;
			}
			/* Please don't laugh at the code below, it works. Certainly can be reduced though. */
			@keyframes backAndForth{
				0%   {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 0%,  rgba(255,255,0,0));}
				1%   {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 2%,  rgba(255,255,0,0));}
				2%   {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 4%,  rgba(255,255,0,0));}
				3%   {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 6%,  rgba(255,255,0,0));}
				4%   {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 8%,  rgba(255,255,0,0));}
				5%   {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 10%, rgba(255,255,0,0));}
				6%   {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 12%, rgba(255,255,0,0));}
				7%   {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 14%, rgba(255,255,0,0));}
				8%   {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 16%, rgba(255,255,0,0));}
				9%   {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 18%, rgba(255,255,0,0));}
				10%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 20%, rgba(255,255,0,0));}
				11%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 22%, rgba(255,255,0,0));}
				12%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 24%, rgba(255,255,0,0));}
				13%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 26%, rgba(255,255,0,0));}
				14%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 28%, rgba(255,255,0,0));}
				15%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 30%, rgba(255,255,0,0));}
				16%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 32%, rgba(255,255,0,0));}
				17%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 34%, rgba(255,255,0,0));}
				18%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 36%, rgba(255,255,0,0));}
				19%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 38%, rgba(255,255,0,0));}
				20%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 40%, rgba(255,255,0,0));}
				21%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 42%, rgba(255,255,0,0));}
				22%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 44%, rgba(255,255,0,0));}
				23%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 46%, rgba(255,255,0,0));}
				24%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 48%, rgba(255,255,0,0));}
				25%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 50%, rgba(255,255,0,0));}
				26%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 52%, rgba(255,255,0,0));}
				27%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 54%, rgba(255,255,0,0));}
				28%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 56%, rgba(255,255,0,0));}
				29%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 58%, rgba(255,255,0,0));}
				30%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 60%, rgba(255,255,0,0));}
				31%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 62%, rgba(255,255,0,0));}
				32%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 64%, rgba(255,255,0,0));}
				33%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 66%, rgba(255,255,0,0));}
				34%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 68%, rgba(255,255,0,0));}
				35%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 70%, rgba(255,255,0,0));}
				36%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 72%, rgba(255,255,0,0));}
				37%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 74%, rgba(255,255,0,0));}
				38%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 76%, rgba(255,255,0,0));}
				39%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 78%, rgba(255,255,0,0));}
				40%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 80%, rgba(255,255,0,0));}
				41%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 82%, rgba(255,255,0,0));}
				42%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 84%, rgba(255,255,0,0));}
				43%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 86%, rgba(255,255,0,0));}
				44%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 88%, rgba(255,255,0,0));}
				45%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 90%, rgba(255,255,0,0));}
				46%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 92%, rgba(255,255,0,0));}
				47%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 94%, rgba(255,255,0,0));}
				48%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 96%, rgba(255,255,0,0));}
				49%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 98%, rgba(255,255,0,0));}
				50%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 100%,rgba(255,255,0,0));}
				51%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 98%, rgba(255,255,0,0));}
				52%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 96%, rgba(255,255,0,0));}
				53%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 94%, rgba(255,255,0,0));}
				54%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 92%, rgba(255,255,0,0));}
				55%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 90%, rgba(255,255,0,0));}
				56%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 88%, rgba(255,255,0,0));}
				57%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 86%, rgba(255,255,0,0));}
				58%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 84%, rgba(255,255,0,0));}
				59%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 82%, rgba(255,255,0,0));}
				60%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 80%, rgba(255,255,0,0));}
				61%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 78%, rgba(255,255,0,0));}
				62%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 76%, rgba(255,255,0,0));}
				63%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 74%, rgba(255,255,0,0));}
				64%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 72%, rgba(255,255,0,0));}
				65%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 70%, rgba(255,255,0,0));}
				66%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 68%, rgba(255,255,0,0));}
				67%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 66%, rgba(255,255,0,0));}
				68%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 64%, rgba(255,255,0,0));}
				69%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 62%, rgba(255,255,0,0));}
				70%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 60%, rgba(255,255,0,0));}
				71%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 58%, rgba(255,255,0,0));}
				72%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 56%, rgba(255,255,0,0));}
				73%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 54%, rgba(255,255,0,0));}
				74%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 52%, rgba(255,255,0,0));}
				75%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 50%, rgba(255,255,0,0));}
				76%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 48%, rgba(255,255,0,0));}
				77%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 46%, rgba(255,255,0,0));}
				78%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 44%, rgba(255,255,0,0));}
				79%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 42%, rgba(255,255,0,0));}
				80%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 40%, rgba(255,255,0,0));}
				81%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 38%, rgba(255,255,0,0));}
				82%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 36%, rgba(255,255,0,0));}
				83%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 34%, rgba(255,255,0,0));}
				84%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 32%, rgba(255,255,0,0));}
				85%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 30%, rgba(255,255,0,0));}
				86%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 28%, rgba(255,255,0,0));}
				87%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 26%, rgba(255,255,0,0));}
				88%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 24%, rgba(255,255,0,0));}
				89%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 22%, rgba(255,255,0,0));}
				90%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 20%, rgba(255,255,0,0));}
				91%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 18%, rgba(255,255,0,0));}
				92%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 16%, rgba(255,255,0,0));}
				93%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 14%, rgba(255,255,0,0));}
				94%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 12%, rgba(255,255,0,0));}
				95%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 10%, rgba(255,255,0,0));}
				96%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 8%,  rgba(255,255,0,0));}
				97%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 6%,  rgba(255,255,0,0));}
				98%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 4%,  rgba(255,255,0,0));}
				99%  {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 2%,  rgba(255,255,0,0));}
				100% {background-image: linear-gradient(to right, rgba(255,255,0,0), rgba(255,255,0,1) 0%,  rgba(255,255,0,0));}
			}
		</style>
		<link rel='icon' href='https://github.com/Just-Roma/Web/blob/Just-something-pretty/Neon%20Bubbles(Neon%20Background)/Bubble_dark.png?raw=true'/>
	</head>

	<body>

		<canvas id='Canvas'></canvas>

		<div id='Menu'>

			<h1>Neon Bubbles</h1>

			<div class='SettingsButtons' id='Settings_Background_Colors'>
				<label for="Background color">Background color(RGB)</label>
				<input type="range" id="backgroundRed"   name="Background color" min="0" max="255" value="255"/>
				<input type="range" id="backgroundGreen" name="Background color" min="0" max="255" value="0"/>
				<input type="range" id="backgroundBlue"  name="Background color" min="0" max="255" value="255"/>
			</div>

			<div class='SettingsButtons' id='Settings_Bubbles_Colors'>
				<label for="Bubbles color">Bubbles color(RGB)</label>
				<input type="range" id="bubblesRed"   name="Bubbles color" min="0" max="255" value="0"/>
				<input type="range" id="bubblesGreen" name="Bubbles color" min="0" max="255" value="255"/>
				<input type="range" id="bubblesBlue"  name="Bubbles color" min="0" max="255" value="255"/>
			</div>

			<div class='SettingsButtons' id='Settings_Number_Of_Bubbles'>
				<label for="Number of bubbles">Number of bubbles</label>
				<input type="range" id="Setting_bubbles_number" name="Number of bubbles" min="0" max="50" value="0"/>
			</div>

			<button id='Change_Background_Button'>Change</button>

		</div>

		<script>
			"use strict";

			/***************************************************************************************\
				This function returns an interface(print and color change) for manipulating "bubbles"
				It's only argument is a canvas object, which will be used for rendering.
				To gain a performance boost a pre-rendering is done internally.
			\***************************************************************************************/

			function createBubbles(canvas){

				/* The bubbles' radiuses are integers. The largest one(stored in refRad) is taken as a reference for creating the others,
					despite the fact that it needs more space. The reason is simple: it looks better by scaling, using the smallest one would create awful results.
					You can play around with this value(set to some positive integer), the code below will response automatically.
				*/
				let refRad = Math.min(120,Math.round(canvas.width*canvas.height/7400));
				if(refRad < 40) refRad = 40; // For mobile screens.

				/* Since a bubbles's pattern is relatively complicated, it would be very inefficient to compute it in each new frame.
					So a stack of frames will be initialised and used later for animation.
					Although scaling images in drawImage is not recommended, we'll do it anyway, otherwise the number of predefined frames will be too large.
					The frames will be stored in a set of small offscreen canvases. 
				*/
				const offCanvas = document.createElement('canvas');

				// The canvas' radius will be 5 pixels larger to make space for a shadow. '+1' to place the bubble exactly in the canvas' center.
				const offCanvasWH = refRad*2 + 11;
				offCanvas.width  = 0;
				offCanvas.height = 0;
				for(let frame = 0; frame < 50; frame++){
					offCanvas[frame] = document.createElement('canvas');
					offCanvas[frame].width  = offCanvasWH;
					offCanvas[frame].height = offCanvasWH;
				}

				// Here the frames are created.
				(function(){

					// Matrix will store the bubble's opacity pattern.
					class Matrix{
						constructor(width, height){
							this.width   = width;
							this.height  = height;
							this.content = Array.from({length: width*height}, () => 0);
						}
						get(x, y)        {return this.content[y*this.width + x];}
						set(x, y, entry) {this.content[y*this.width + x] = entry;}
					}
					let bubMat = new Matrix(refRad*2+1, refRad*2+1); // '+1' to place the center at the right position, namely at the index 60.
					let dist;

					/* Opacity corresponds to the exponential distribution(lambda = 1), but the normal results will be too smooth.
						To make it more "rugged" a random value from [-0.15, 0.15] is added, these values are chosen arbitrarily, based on my taste.
						The x axis must be scaled, otherwise the majority of values will be ~ 0. The area between 0 and 3.(3) covers ~ 96 % of distribution.
					*/
					for(let x = refRad*2; x >= 0; x--){
						for(let y = refRad*2; y >= 0; y--){
							dist = Math.sqrt((x-refRad)**2 + (y-refRad)**2);
							if (dist <= refRad){
								bubMat.set(x, y, (Math.random()*3-1.5)/10 + Math.exp((dist-refRad)/(refRad/3.333333)));
							}
						}
					}

					/* ImageData object will be filled and then printed on the canvas. It's much faster than filling the canvas.
						Though constructor ImageData can be used, it's experimental(not completely supported) at the date of writing. */
					let imageData = offCanvas.getContext('2d').createImageData(refRad*2+1, refRad*2+1);
					let ctxFrame;

					let amplifier = 1.5;

					/* Each frame will be filled with some color(R=G=B) from [100, 200], which correlates with opacity.
						This colors' range was chosen to make bubbles as juicy as possible but not too bright.
						It can be adjusted below to get another rendering results.
					*/
					let colors, color;
					let center = refRad+5; // bubble's center on an off-screen canvas.

					for (let frame = 49; frame >= 0; frame--){
						amplifier -= 0.03;
						color = Math.max(100, Math.round(133*amplifier));
						imageData.data.fill(color);
						for(let x = refRad*2; x >= 0; x--){
							for(let y = refRad*2; y >= 0; y--){
								imageData.data[y*(refRad*2+1)*4 + 4*x+3] = 255*bubMat.get(x, y)*amplifier;
							}
						}

						ctxFrame = offCanvas[frame].getContext('2d');
						ctxFrame.putImageData(imageData, 5, 5);

						// Without this filling a part of the bubble's center will be too dark.
						colors = 'rgba(' + color + ',' + color + ',' + color + ',';
						ctxFrame.fillStyle = colors + amplifier/5 + ')';
						ctxFrame.beginPath();
						ctxFrame.arc(center, center, refRad+1, 0, Math.PI *2);
						ctxFrame.fill();

						// Add a shadow to make the bubble slightly more beautiful.
						ctxFrame.shadowColor = colors + '1)';
						ctxFrame.shadowBlur = 5;

						// These strokes exist solely to make the bubble's external circle smoother, the shadow will be also put on them.
						ctxFrame.strokeStyle = colors + amplifier + ')';
						ctxFrame.beginPath();
						ctxFrame.arc(center, center, refRad-0.5, 0, Math.PI *2);
						ctxFrame.stroke();
						ctxFrame.beginPath();
						ctxFrame.arc(center, center, refRad, 0, Math.PI *2);
						ctxFrame.stroke();
						ctxFrame.beginPath();
						ctxFrame.arc(center, center, refRad+0.5, 0, Math.PI *2);
						ctxFrame.stroke();
						ctxFrame.shadowBlur = 0; // Don't forget to turn off the shadow.
					}
				})();

				class Bubble{

					constructor(){
						this.x;
						this.y;
						this.radius;
						this.speed;
						this.rgb;
						this.amplifier;     // Used to amplify opacity.
						this.amplifier_max;
						this.scale;         // Used to scale the pre-rendered canvas.
					}

					// Support function for checking the distance between bubbles.
					checkPos(curBub){
						for(let i = n_bubbles-1; i >= 0; i--){
							if(curBub != o_O[i] && (Math.sqrt((curBub.x - o_O[i].x)**2 + (curBub.y - o_O[i].y)**2) < (curBub.radius + o_O[i].radius)/2)) return true;
						}
						return false;
					}

					selfChange(){
						// Max amplifier lies betwen 35 and 50.
						this.amplifier_max = Math.round((3.5 + 1.5*Math.random())*10);

						/* It does not look good when bubbles overlap too much, give em a chance to find an empty spot.
							Testing showed that increasing the min allowed distance spawns lots of little bubbles, 
							besides it does not really look better when they don't overlap. */
						let i = 0;
						do{
							this.radius = 25 + Math.round(Math.random()*(refRad-25));

							this.speed = refRad/this.radius;

							//	The valid width range is reduced by radius from the left/right side. 26 is because of the border from main.js
							this.x = 26 + this.radius + Math.round(Math.random()*(width - 2*this.radius - 52));

							// the possible start position is shifted downwards, so bubbles won't flow beyond canvas.
							this.y = this.radius + Math.ceil((this.amplifier_max*2-1)*this.speed + Math.random()*(height - (2*this.radius + (this.amplifier_max*2-1)*this.speed)));

							i++;
						}while(this.checkPos(this) && i < 20);

						// To make the picture more interesting the bubbles will have slightly different colors.
						this.rgb = 'rgba(' + (RGB[0]-25+Math.round(Math.random()*50)) + ','
												 +	(RGB[1]-25+Math.round(Math.random()*50)) + ','
												 +	(RGB[2]-25+Math.round(Math.random()*50)) + ',';

						this.amplifier = this.amplifier_max-1;

						this.scale = this.radius/refRad;
					}

					print(){

						/* First print the scaled opacity frame to put a basement for the further coloring.
							The value of currentAmplifier is automatically calculated, it goes from 1 to 'amplifier_max' and then back to 1.
							The second/third arguments must be shifted to the left top corner by the scaled frame radius.
						*/
						let currentAmplifier = this.amplifier_max - Math.abs(this.amplifier % this.amplifier_max);
						ctx.drawImage(offCanvas[currentAmplifier - 1],
										  this.x - (refRad + 5)*this.scale,
										  this.y - (refRad + 5)*this.scale,
										  this.scale*offCanvasWH,
										  this.scale*offCanvasWH);

						// Put a color on the basement, fillStyle's opacity must be adjusted according to "currentAmplifier".
						ctx.globalCompositeOperation = 'color';
						ctx.fillStyle = this.rgb + currentAmplifier/this.amplifier_max + ')';
						ctx.beginPath();
						ctx.arc(this.x, this.y, this.radius+1, 0, Math.PI *2);
						ctx.fill();

						// Change back the mode and actualize the current Bubble's parameters.
						ctx.globalCompositeOperation = 'source-over';
						this.y -= this.speed;
						this.amplifier -= 1;
						if (this.amplifier == -this.amplifier_max) this.selfChange();
					}
				}

				// Local reference to the canvas' context.
				const ctx = canvas.getContext('2d');

				// '-1' to avoid placing a part of a bubble beyond the canvas.
				const width = canvas.width - 1;
				const height = canvas.height - 1;

				// n_bubbles restricts the amount of bubbles to be printed, max allowed number is 50.
				let n_bubbles = Math.min(50, Math.round(width*height/15000));

				// RGB defines the "average" color of a bubble.
				let RGB = [0, 255, 255];

				// Bubbles' initialization.
				const o_O = Array.from({length: 50}, () => new Bubble());
				for (let i = 0; i < 50; i++) {o_O[i].selfChange();}

				return {
					red  (new_color){RGB[0] = Number(new_color.target.value);},
					green(new_color){RGB[1] = Number(new_color.target.value);},
					blue (new_color){RGB[2] = Number(new_color.target.value);},
					size (n){n_bubbles = Number(n.target.value);},
					setTag(tagId){document.getElementById(tagId).value = n_bubbles;},
					print(){for (let i = n_bubbles-1; i >= 0; i--) o_O[i].print();}
				}
			};

			/* This function distributes the background dots(colorful pixels).
				First dots are distributed uniformly, after that a set of "dots clouds" is put on the canvas.
			*/

			let createBackground = function(canvas){

				const ctx  = canvas.getContext('2d');
				let width  = canvas.width;
				let height = canvas.height;

				let O_o = ctx.createImageData(width, height); // Will contain the dots.
				let directions; // A support object which will store the direction of opacity change(should it become brighter or fainter).
				let RGB = [255, 0, 255]; // Default RGB.
				let dotsCounter;

				// The background is created here.
				function modifyBackground(){

					O_o.data.fill(0); // Clean the background. Necessary if a user clicks on the change button.

					let newX, newY, index;
					// We dont want to place a dot outside of the canvas, so -1.
					let W = width - 1;
					let H = height - 1;

					// 0.5% of the canvas' area is uniformly filled.
					for(let nDots = Math.floor(0.005*width*height); nDots > 0; nDots--){

						do{
							newX = Math.round(Math.random()*W);
							newY = Math.round(Math.random()*H);
						}while(O_o.data[newY*width*4 + 4*newX+3]);

						index = newY*width*4 + 4*newX;
						O_o.data[index]   = RGB[0] - 25+Math.random()*50;
						O_o.data[index+1] = RGB[1] - 25+Math.random()*50;
						O_o.data[index+2] = RGB[2] - 25+Math.random()*50;
						O_o.data[index+3] = 17*Math.round(1+Math.random()*13); // Some random opacity is set to create the flickering effect.
					}
					dotsCounter = Math.floor(0.005*width*height);

					/* Here is the more interesting part. It puts the "dots clouds" on the canvas. These are gauss distributed groups of single dots.
						x/y is the center of a such group, 
						Pr decides if a current group can spawn another group, 
						dir(direction) used to avoid placing groups back on already taken spots.
					*/
					function clouds(x, y, Pr, dir = 0){

						if (x < 20 || x > W-20 || y < 20 || y > H-20) return;

						/* 'amplifier' will "stretch" our random standard gauss. 
							Math.log(Math.random()) is the random number generator for the standard exponential distribution.
							This range is taken because i thought that results look good enough.
						*/
						let amplifier = 2 - Math.log(Math.random());

						let U,V; // variables for the Box-Muller algorithm(aka random gauss).

						// there is a possibility that a new group's center will 'land' on a highly dense area, so some protection from infinite loop is needed.
						let protection;
						for (let nDots = Math.round(2*amplifier); nDots > 0; nDots--)
						{
							protection = 0;

							do{
								// Here Box-Muller algorithm.
								U = Math.random(); V = Math.random();
								newX = Math.round(x + amplifier*Math.sqrt(-2*Math.log(U))*Math.cos(2*Math.PI*V));
								newY = Math.round(y + amplifier*Math.sqrt(-2*Math.log(U))*Math.sin(2*Math.PI*V));

								protection++;
								if (protection >= 10) break;

								/* Since gauss exists on all real numbers, it is possible that extreme values will be produced(unlikely though).
									Just to be sure that our positions lie within the correct range, x/y are checked. 
									2 pixels are added because of the border from main.js.
								*/
							}while (newX < 2 || newX > width-2 || newY < 0 || newY >= height || O_o.data[newY*width*4 + 4*newX+3]);

							if(protection >= 10) break;

							index = newY*width*4 + 4*newX;
							// Some color variation is introduced.
							O_o.data[index]   = RGB[0] - 25+Math.random()*50;
							O_o.data[index+1] = RGB[1] - 25+Math.random()*50;
							O_o.data[index+2] = RGB[2] - 25+Math.random()*50;
							O_o.data[index+3] = 17*Math.round(1+Math.random()*13);
							dotsCounter++;
						}

						/* It is unnecessary to spawn new centers in the previous direction from where it came, so for each case one direction must be excluded.
							-Math.log(Math.random())/(1/amplifier) is the random exponential distribution. 
							Lambda depends on amplifier. Larger amplifier throws the new center further away.
							'amplifier*2' is added to lower the possibility of too dense clusters.
						*/
						if(Math.random() < Pr && amplifier/15 < Math.random() && dir != 4){
							clouds(x+amplifier*2+(-Math.log(Math.random())/(1/amplifier)), y+amplifier*2+(-Math.log(Math.random())/(1/amplifier)), Pr-0.01, 1);
						}
						if(Math.random() < Pr && amplifier/15 < Math.random() && dir != 3){
							clouds(x-amplifier*2-(-Math.log(Math.random())/(1/amplifier)), y+amplifier*2+(-Math.log(Math.random())/(1/amplifier)), Pr-0.01, 2);
						}
						if(Math.random() < Pr && amplifier/15 < Math.random() && dir != 2){
							clouds(x+amplifier*2+(-Math.log(Math.random())/(1/amplifier)), y-amplifier*2-(-Math.log(Math.random())/(1/amplifier)), Pr-0.01, 3);
						}
						if(Math.random() < Pr && amplifier/15 < Math.random() && dir != 1){
							clouds(x-amplifier*2-(-Math.log(Math.random())/(1/amplifier)), y-amplifier*2-(-Math.log(Math.random())/(1/amplifier)), Pr-0.01, 4);
						}
					}

					/* Some number of clouds based on the resolution is chosen. 
						The allowed area is reduced to decrease the probability that clouds on the canvas' edges will be cut. */
					for (let i = Math.round(width*height/25000); i >= 0; i--) clouds(50 + Math.random()*(width-100),75+ Math.random()*(height-150), 0.5);

					/* The 'directions' array is filled here. 30 bits(starting from LSB) correspond to the dot's index in O_o(Image map).
						the 31th bit is used for direction(1 or 0). */
					directions = Array.from({length: dotsCounter}, () => Math.round(Math.random()));
					dotsCounter--;
					for(let x = W; x >= 0; x--){
						for(let y = H; y >= 0; y--){
							if(!O_o.data[y*width*4 + x*4+3]) O_o.data[y*width*4 + x*4+3] = 255; // Make the unoccupied spots untransparent.
							else{
								directions[dotsCounter] = ((directions[dotsCounter] << 30) | (y*width*4 + x*4+3));
								dotsCounter--;
							}
						}
					}
				}
				modifyBackground();

				/* >>30 to extract the direction, &1073741823 to extract the index, 1073741823 is 2^30-1 in binary, 1111...111 30 times.
					|1073741824 to set the direction. 1073741824 is 2^30 or 1000...000 */
				function actualiseDots(){

					for(let dot = directions.length-1; dot >= 0; dot--){

							if(directions[dot] >> 30) O_o.data[directions[dot] & 1073741823] += 17;
							else O_o.data[directions[dot] & 1073741823] -= 17;

							if (O_o.data[directions[dot] & 1073741823] == 0)   directions[dot] |= 1073741824;
							if (O_o.data[directions[dot] & 1073741823] == 255) directions[dot] &= 1073741823;
					}
				}

				function modifyColor(offset){
					let color_index = Math.abs(offset-3);
					for(let dot = directions.length-1; dot >= 0; dot--){
						O_o.data[(directions[dot] & 1073741823) - offset] = RGB[color_index] - 25+Math.random()*50;
					}
				}

				let shift = 0; // Used for rotation.
				return{
					red  (new_color){RGB[0] = Number(new_color.target.value); modifyColor(3);},
					green(new_color){RGB[1] = Number(new_color.target.value); modifyColor(2);},
					blue (new_color){RGB[2] = Number(new_color.target.value); modifyColor(1);},
					modifyBackground,
					print(){
						// Separate the image into two blocks to create a rotating effect.
						ctx.putImageData(O_o, 0, shift, 0, 0, width, height-shift);
						ctx.putImageData(O_o, 0, -height+shift+1, 0, height-shift, width,shift);
						actualiseDots();
						shift = (shift+1)%height;
					}
				}
			};
			/* This is the main script for the animation.
				It defines the canvas' properties and sets some event listeners for the user interaction.
			*/

			const Canvas = document.getElementById('Canvas');
			let ctx, background, bubbles, set_border;

			/* This function prints a transparency "transition border", which makes every canvas' edge progressively transparent.
				The main intention of this border is to let the background slowly come "out of nowhere" from the top and "dissappear" at the bottom.
				Though this border could be prerendered on an off-screen canvas, testing showed no significant difference.
			*/

			function initializeBorder(){

				const ctx    = Canvas.getContext('2d');
				const width  = Canvas.width;
				const height = Canvas.height;
				let shift; // 'shift' will change the area to be filled, otherwise some pixels will be colored by different expressions.

				return function(){

					shift = 0;
					for(let i = 25; i >= 0; i--){
						ctx.fillStyle = 'rgba(0,0,0,' + i/25 +')';

						// top: *2 because each new top border layer has 2 pixels fewer.
						ctx.fillRect(shift, shift, width-shift*2, 1);

						// bottom: -1 in the second arg, cause indexing starts with 0, so the last index is height-1.
						ctx.fillRect(shift, height-shift-1, width-shift*2, 1);

						// left: +1 in the second arg to not overlap with the top border.
						// (shift+1) because it starts at the index 1(aka second row).
						ctx.fillRect(shift, shift+1, 1, height-(shift+1)*2);

						//right: -1 in the first arg for the same reason as in the bottom.
						ctx.fillRect(width-shift-1,shift+1, 1, height-(shift+1)*2);

						shift++;
					}
					/* this border construction looks like this:
						-------
						|-----|
						||---||
						||   ||
						||---||
						|-----|
						-------  '-' is for top and bottom and '|' for left and right. Each pixel is colored only once.
					*/
				}
			};

			let backgroundRed = document.getElementById('backgroundRed');
			let backgroundGreen = document.getElementById('backgroundGreen');
			let backgroundBlue = document.getElementById('backgroundBlue');
			let bubblesRed = document.getElementById('bubblesRed');
			let bubblesBlue = document.getElementById('bubblesBlue');
			let bubblesGreen = document.getElementById('bubblesGreen');
			let bubblesNumberSetter = document.getElementById('Setting_bubbles_number');

			function initializeAll(){

				// Set canvas' sizes according to the window's size.
				Canvas.width  = Math.round(window.innerWidth* 0.85);
				Canvas.height = window.innerHeight;

				// Create bubbles/background objects.
				background = createBackground(Canvas);

				backgroundRed.addEventListener('change', background.red);
				backgroundGreen.addEventListener('change', background.green);
				backgroundBlue.addEventListener('change', background.blue);

				bubbles = createBubbles(Canvas);

				bubblesRed.addEventListener('change', bubbles.red);
				bubblesGreen.addEventListener('change', bubbles.green);
				bubblesBlue.addEventListener('change', bubbles.blue);
				bubblesNumberSetter.addEventListener('change', bubbles.size);

				// Reset the values.
				backgroundRed.value = '255';
				backgroundGreen.value = '0';
				backgroundBlue.value = '255';

				bubblesRed.value = '0';
				bubblesGreen.value = '255';
				bubblesBlue.value = '255';

				bubbles.setTag('Setting_bubbles_number');

				set_border = initializeBorder();
			};
			initializeAll();

			// Change the canvas by window resizing.
			window.addEventListener('resize',()=> initializeAll());

			document.getElementById('Change_Background_Button').addEventListener('click', () => background.modifyBackground());

			(function march(){
				background.print();
				bubbles.print();
				set_border();
				setTimeout(march, 50);
			})();
		</script>
	</body>
</html>
