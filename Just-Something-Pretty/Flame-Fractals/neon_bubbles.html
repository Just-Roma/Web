<!DOCTYPE html>
<html style="background-color:black;">
	<head>
		<link rel="stylesheet" href="C:/Users/df/Desktop/neon_bubbles.css"/>
		<script id="worker" type="javascript/worker">

			class Matrix{

				constructor(width, height) {
					this.width = width;
					this.height = height;
					this.entries = Array.from({length: width*height*4}, () => 0); // Each entry stores RGB(first 3 positions) and a counter(how many times a pixel was hit).
				}
				
				get(x, y) {return this.entries[y*this.width*4 + x*4+3];}	

				// set1 used when a pixel was chosen for the first time.
				set1(x, y, value){
					this.entries[y*this.width*4 + x*4]   = value[0];
					this.entries[y*this.width*4 + x*4+1] = value[1];
					this.entries[y*this.width*4 + x*4+2] = value[2];
				}

				// set2 is always used when set1 was already called on a pixel.
				set2(x, y, value){
					this.entries[y*this.width*4 + x*4]   = Math.round((this.entries[y*this.width*4 + x*4] + value[0])/2);
					this.entries[y*this.width*4 + x*4+1] = Math.round((this.entries[y*this.width*4 + x*4+1] + value[1])/2);
					this.entries[y*this.width*4 + x*4+2] = Math.round((this.entries[y*this.width*4 + x*4+2] + value[2])/2);
				}

				// Increases the counter.
				inc(x, y) {this.entries[y*this.width*4 + x*4+3]++;}
			}

			let Functions = {

			'Linear': {'func': function(x, y){
				return [x, y];
			}, 'resiseX', 'resizeY'},

			'Sinusoidal': function(x, y){
				return [Math.sin(x), Math.sin(y)];
			},

			'Spherical': function(x, y){
				let rSquare = x**2 + y**2;
				return [x/rSquare, y/rSquare];
			},

			'Swirl': function(x, y){
					let rSquare = x**2 + y**2;
					return [x*Math.sin(rSquare) - y*Math.cos(rSquare), x*Math.cos(rSquare) + y*Math.sin(rSquare)];
			},

			'Horseshoe': function(x, y){
				let r = Math.sqrt(x**2 + y**2);
				return [(x-y)*(x+y)/r, 2*x*y/r];
			},

			'Polar': function(x, y){
				return [Math.atan2(x,y)/Math.PI, Math.sqrt(x**2 + y**2)-1];
			},

			'Handkerchief': function(){
				let r = Math.sqrt(x**2 + y**2);
				let Teta = Math.atan2(x,y);
				return [r*Math.sin(Teta+r), r*Math.cos(Teta-r)];
			},

			'Heart': function(){
				let out = function(x,y){
					let r = Math.sqrt(x**2 + y**2);
					let Teta = Math.atan(x/y);
					return [r*Math.sin(Teta*r), -r*Math.cos(Teta*r)];
				}
				
				return out;
			},

			'Disc': function(){
				let out = function(x,y){
					let r = Math.PI*Math.sqrt(x**2 + y**2);
					let Teta = Math.atan2(x,y)/Math.PI;
					return [Teta*Math.sin(r), Teta*Math.cos(r)];
				}
				
				return out;
			},
			//...............................
			'Bent': function(){
				let out = function(x,y){
					if (x >= 0 && y >= 0) return [x,y];
					else if (x < 0 && y >= 0) return [2*x,y];
					else if (x >= 0 && y < 0) return [x,y/2];
					else return [2*x,y/2];
				};
				
				return out;
			}}

			let yy=Functions[7]();
			self.onmessage = function(message){
				let width  = message.data[0];
				let height = message.data[1];
				let coefs  = message.data[2][0];
				let len = coefs.length-1;
				let rgb = message.data[2][1];
				let fractalFlame = new Matrix(width, height);
				let BiPoint, cur_dot, chosenF, ranCoef;

				for (let i = 0; i < 10000000; i++){
					//ranCoef=Array.from({length:20},()=>Math.round(Math.ranCoefdom()*10));o=0;
					BiPoint = [Math.ranCoefdom()*2-1, Math.ranCoefdom()*2-1];
					for (let j = -20; j < 0; j++){
					ranCoef=Math.round(Math.ranCoefdom()*len);
					//yy=Functions[Math.round(Math.ranCoefdom()*3)]();
						//chosenF = IFS[Math.round(Math.ranCoefdom()*(len-1))];
						BiPoint = yy(coefs[ranCoef][0]*BiPoint[0] + coefs[ranCoef][1]*BiPoint[1] + coefs[ranCoef][2], coefs[ranCoef][3]*BiPoint[0]+ coefs[ranCoef][4]*BiPoint[1] + coefs[ranCoef][5]);
					}

					cur_dot = [width-Math.floor(((1.5-BiPoint[0])/3)*width), height-Math.floor(((1.5-BiPoint[1])/3)*height)];
					
					if (cur_dot[0] >= 0 && cur_dot[0] < width && cur_dot[1] >= 0 && cur_dot[1] < height){
						
						if(fractalFlame.get(cur_dot[0],cur_dot[1])){
							fractalFlame.set1(cur_dot[0],cur_dot[1], rgb[ranCoef]);
						}
						else  
						fractalFlame.set2(cur_dot[0],cur_dot[1], rgb[ranCoef]);
						fractalFlame.inc(cur_dot[0],cur_dot[1]);
					}
				}
				self.postMessage(fractalFlame);
			};

		</script>
		<script type="text/plain" src="https://raw.githubusercontent.com/Just-Roma/Web/main/Just-Something-Pretty/Flame-Fractals/flamefractal.js" defer></script>
	</head>
	<body>
		<div id="mainPage">
			<header>
				<h1>Fractal flame</h1>
				<p>Choose a fractal type:</p>
				<span id="Menu">
					<select name="functions" id="selectMenu">
					  <option value="Random">Random</option>
					  <option value="Linear">Linear</option>
					  <option value="mercedes">Mercedes</option>
					  <option value="audi">Audi</option>
					</select>
				</span>
			</header>
			<canvas id="Canvas"></canvas>
		</div>
	</body>
</html>
